package org.trainman.service.util;

import org.trainman.model.Employee;
import org.apache.poi.ss.usermodel.*;
import org.apache.poi.xssf.usermodel.XSSFWorkbook;

import java.io.InputStream;
import java.time.LocalDate;
import java.time.format.DateTimeFormatter;
import java.time.format.DateTimeParseException;
import java.util.*;

public class ExcelParser {

    public static class ParseResult {
        private final List<Employee> employees = new ArrayList<>();
        private final List<String> errors = new ArrayList<>();

        public List<Employee> getEmployees() { return employees; }
        public List<String> getErrors() { return errors; }
    }

    // === Positional parser (for template order) ===
    public static ParseResult parse(InputStream in) {
        ParseResult result = new ParseResult();
        try (Workbook wb = WorkbookFactory.create(in)) {
            Sheet sheet = wb.getSheetAt(0);
            for (int i = 1; i <= sheet.getLastRowNum(); i++) {
                Row row = sheet.getRow(i);
                if (row == null) continue;
                try {
                    Employee e = new Employee();
                    // --- Updated canonical order ---
                    e.setEmpId(getString(row, 0));
                    e.setName(getString(row, 1));
                    e.setGender(getString(row, 2));
                    e.setDoj(getDate(row, 3));
                    e.setNsbtBatchNo(getString(row, 4));
                    e.setStatus(getString(row, 5));
                    e.setGrade(getString(row, 6));
                    e.setBu(getString(row, 7));
                    e.setMprNo(getString(row, 8));
                    e.setIoName(getString(row, 9));
                    e.setReleasedDate(getDate(row, 10));
                    e.setResignationDate(getDate(row, 11));

                    // Apply ranking logic
                    if ("Under Training".equalsIgnoreCase(e.getStatus())) {
                        e.setGrade(null);
                        e.setRanking(null);
                    } else if ("Terminated".equalsIgnoreCase(e.getStatus())) {
                        e.setGrade("D");
                        e.setRanking("NI");
                    } else {
                        e.setRanking(RankingUtil.mapGradeToRanking(e.getGrade(), e.getStatus()));
                    }

                    result.getEmployees().add(e);
                } catch (Exception ex) {
                    result.getErrors().add("Row " + (i + 1) + ": " + ex.getMessage());
                }
            }
        } catch (Exception e) {
            result.getErrors().add("Fatal parse error: " + e.getMessage());
        }
        return result;
    }

    // --- Helpers ---
    private static String getString(Row r, int idx) {
        Cell c = r.getCell(idx);
        return formatCellAsString(c);
    }

    private static LocalDate getDate(Row r, int idx) {
        Cell c = r.getCell(idx);
        if (c == null) return null;
        if (c.getCellType() == CellType.NUMERIC && DateUtil.isCellDateFormatted(c)) {
            return c.getLocalDateTimeCellValue().toLocalDate();
        }
        String s = formatCellAsString(c);
        if (s == null || s.isEmpty()) return null;
        return parseLenientDate(s);
    }

    private static String formatCellAsString(Cell c) {
        if (c == null) return null;
        try {
            Workbook wb = c.getSheet().getWorkbook();
            DataFormatter formatter = new DataFormatter();
            FormulaEvaluator evaluator = wb.getCreationHelper().createFormulaEvaluator();
            String text = formatter.formatCellValue(c, evaluator);
            if (text == null) return null;
            text = text.replace('\u00A0', ' ').replace('\u200B', ' ').replace('\uFEFF', ' ');
            text = text.replaceAll("\\s+", " ").trim();
            return text.isEmpty() ? null : text;
        } catch (Exception ex) {
            return c.toString().trim();
        }
    }

    // --- Date parsing setup ---
    private static final DateTimeFormatter DTF = DateTimeFormatter.ofPattern("dd-MM-yyyy");
    private static final DateTimeFormatter DTF_DD_MMM_YYYY = DateTimeFormatter.ofPattern("dd-MMM-yyyy", Locale.ENGLISH);
    private static final DateTimeFormatter DTF_DD_MMM_YY = DateTimeFormatter.ofPattern("dd-MMM-yy", Locale.ENGLISH);
    private static final DateTimeFormatter DTF_SLASH = DateTimeFormatter.ofPattern("dd/MM/yyyy");
    private static final DateTimeFormatter ISO = DateTimeFormatter.ISO_LOCAL_DATE;

    private static final List<DateTimeFormatter> DATE_FORMATTERS = Arrays.asList(
            ISO, DTF, DTF_DD_MMM_YYYY, DTF_DD_MMM_YY, DTF_SLASH
    );

    private static LocalDate parseLenientDate(String s) {
        if (s == null) throw new DateTimeParseException("null", "", 0);
        for (DateTimeFormatter fmt : DATE_FORMATTERS) {
            try { return LocalDate.parse(s, fmt); }
            catch (DateTimeParseException ignored) {}
        }
        String cleaned = s.replace('.', '-').replaceAll("\\s+", "-").replaceAll("[^0-9A-Za-z-]", "-");
        for (DateTimeFormatter fmt : DATE_FORMATTERS) {
            try { return LocalDate.parse(cleaned, fmt); }
            catch (DateTimeParseException ignored) {}
        }
        throw new DateTimeParseException("Unrecognized date format: " + s, s, 0);
    }

    private static final Set<String> ALLOWED_STATUS = new HashSet<>(Arrays.asList(
            "Allocated", "Under Training", "Resigned", "Terminated", "Temp Allocation", "Waiting for Allocation"
    ));

    // === Header-aware parser ===
    public static ParseResult parseXlsx(InputStream in) throws Exception {
        ParseResult result = new ParseResult();
        try (Workbook wb = new XSSFWorkbook(in)) {
            Sheet sheet = wb.getSheetAt(0);
            if (sheet == null) {
                result.errors.add("Workbook has no sheets");
                return result;
            }

            Map<String, Integer> colIndex = Collections.emptyMap();
            int headerRowNum = sheet.getFirstRowNum();
            for (int hr = sheet.getFirstRowNum(); hr <= sheet.getFirstRowNum() + 2 && hr <= sheet.getLastRowNum(); hr++) {
                Row headerRow = sheet.getRow(hr);
                if (headerRow == null) continue;
                Map<String, Integer> candidate = safeMapHeader(headerRow);
                if (!candidate.isEmpty() && candidate.containsKey("empid") && candidate.containsKey("name")) {
                    colIndex = candidate;
                    headerRowNum = hr;
                    break;
                }
            }

            boolean usedPositionalFallback = false;
            if (colIndex.isEmpty()) {
                usedPositionalFallback = true;
                Map<String, Integer> positional = new HashMap<>();
                positional.put("empid", 0);
                positional.put("name", 1);
                positional.put("gender", 2);
                positional.put("doj", 3);
                positional.put("nsbt batchno", 4);
                positional.put("status", 5);
                positional.put("grade", 6);
                positional.put("bu", 7);
                positional.put("mpr no", 8);
                positional.put("io name", 9);
                positional.put("released date", 10);
                positional.put("resignation date", 11);
                colIndex = positional;
            }

            for (int r = headerRowNum + 1; r <= sheet.getLastRowNum(); r++) {
                Row row = sheet.getRow(r);
                if (row == null) continue;
                int rowNum = row.getRowNum() + 1;

                try {
                    Employee e = new Employee();
                    e.setEmpId(getCellString(row, colIndex.get("empid")));
                    if (e.getEmpId() == null) {
                        result.errors.add("Row " + rowNum + ": Missing EMP_ID");
                        continue;
                    }
                    e.setName(getCellString(row, colIndex.get("name")));
                    e.setGender(getCellString(row, colIndex.get("gender")));
                    e.setNsbtBatchNo(getCellString(row, colIndex.get("nsbt batchno")));
                    e.setStatus(getCellString(row, colIndex.get("status")));
                    e.setGrade(getCellString(row, colIndex.get("grade")));
                    e.setBu(getCellString(row, colIndex.get("bu")));
                    e.setMprNo(getCellString(row, colIndex.get("mpr no")));
                    e.setIoName(getCellString(row, colIndex.get("io name")));

                    LocalDate doj = parseDateCell(row, colIndex.get("doj"));
                    LocalDate releasedDate = parseDateCell(row, colIndex.get("released date"));
                    LocalDate resignationDate = parseDateCell(row, colIndex.get("resignation date"));

                    e.setDoj(doj);
                    e.setReleasedDate(releasedDate);
                    e.setResignationDate(resignationDate);

                    result.employees.add(e);
                } catch (Exception ex) {
                    result.errors.add("Row " + rowNum + ": " + ex.getMessage());
                }
            }

            if (usedPositionalFallback) {
                result.errors.add(0, "Warning: header not detected; positional fallback used (new template order).");
            }
        }
        return result;
    }

    private static String getCellString(Row row, Integer idx) {
        if (idx == null) return null;
        Cell c = row.getCell(idx);
        if (c == null) return null;
        if (c.getCellType() == CellType.NUMERIC && DateUtil.isCellDateFormatted(c)) {
            LocalDate d = c.getLocalDateTimeCellValue().toLocalDate();
            return d.format(DTF);
        }
        return formatCellAsString(c);
    }

    private static LocalDate parseDateCell(Row row, Integer idx) {
        if (idx == null) return null;
        Cell c = row.getCell(idx);
        if (c == null) return null;
        if (c.getCellType() == CellType.NUMERIC && DateUtil.isCellDateFormatted(c))
            return c.getLocalDateTimeCellValue().toLocalDate();
        String s = formatCellAsString(c);
        if (s == null || s.isEmpty()) return null;
        return parseLenientDate(s);
    }

    // --- Fixed header mapping (corrected keys) ---
    private static Map<String, Integer> safeMapHeader(Row header) {
        Map<String, Integer> idx = new HashMap<>();
        if (header == null) return idx;
        for (Cell c : header) {
            String v = formatCellAsString(c);
            if (v == null) continue;
            idx.put(v.trim().toLowerCase(), c.getColumnIndex());
        }
        Map<String, Integer> normalized = new HashMap<>();
        for (Map.Entry<String, Integer> e : idx.entrySet()) {
            String k = e.getKey().replaceAll("[^a-z0-9]", "");
            if (k.contains("empid")) normalized.put("empid", e.getValue());
            if (k.contains("name")) normalized.put("name", e.getValue());
            if (k.contains("gender") || k.equals("sex")) normalized.put("gender", e.getValue());
            if (k.contains("doj") || k.contains("dateofjoining")) normalized.put("doj", e.getValue());
            if (k.contains("nsbt") || k.contains("batchno")) normalized.put("nsbt batchno", e.getValue());
            if (k.contains("status")) normalized.put("status", e.getValue());
            if (k.contains("grade")) normalized.put("grade", e.getValue());
            if (k.equals("bu") || k.contains("businessunit")) normalized.put("bu", e.getValue());
            if (k.contains("mpr")) normalized.put("mpr no", e.getValue());
            if (k.contains("io") || k.contains("immediateofficer")) normalized.put("io name", e.getValue());
            if (k.contains("released")) normalized.put("released date", e.getValue());
            if (k.contains("resignation") || k.contains("leaving")) normalized.put("resignation date", e.getValue());
        }
        return normalized;
    }
}
